<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta charset="UTF-8" />
		<title>JavaScript(Core and Client)</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="shortcut icon" href="../favicon.ico" />
		<style>
			section {
				margin: 2px;
				padding: 3px;
				border: 1px solid lightgrey;
				border-radius: 5px;
			}
		</style>
	</head>
	<body>
		<header role="banner">
			<h1>JavaScript(Core and Client)</h1>
			<p>コア及びクライアントサイドのJavaScriptの練習サイトです。</p>
		</header>

		<main>
			<section>
				<h2>クロージャ</h2>
				<section>
					<h3>thisの扱い</h3>
					<button class="ClosureButton">0</button>
					<button class="ClosureButton">0</button>
					<button class="ClosureButton">0</button>
					<script>
						(function (doc) {
							var btns = doc.querySelectorAll(".ClosureButton");

							for (var i = 0; i < btns.length; i++) {
								btns[i].onclick = (function (x) {
									return function () {
										this.innerHTML = x + 1;
									};
								}(i));

//								btns[i].onclick = (function (x, that) {
//									return function () {
//										that.innerHTML = x + 1;
//									};
//								}(i, btns[i]));
							}
						}(document));
					</script>
				</section>
			</section>
			<section>
				<style scoped="scoped">
					.NewClass {
						color: red;
						font-weight: bold;
						/*font-size: 150%;*/
					}
				</style>
				<h2>クラスリスト</h2>
				<p id="ClassListSampleElement" class="Hoge Foo Bar">サンプル</p>
				<button id="ToggleClass">Toggle class</button>
				<textarea id="ClassListResult" readonly="readonly" cols="40" rows="5">
				</textarea>
				<script>
					(function (win, doc) {

						var sample = doc.getElementById("ClassListSampleElement"),
							sampleClass = "NewClass",
							toggler = doc.getElementById("ToggleClass"),
							result = doc.getElementById("ClassListResult");

						function addEvent(ele, type, fn, cap) {
							ele.addEventListener(type, fn, cap);
						}

						function init() {
							result.value = "";

							sample.classList.add(sampleClass);

							for (var i = 0; i < sample.classList.length; i++) {
								result.value += sample.classList[i];
								result.value += "\n";
							}

							addEvent(toggler, "click", function () {
								sample.classList.toggle(sampleClass);
							});

							setTimeout(function () {
								sample.classList.remove(sampleClass);
							}, 3000);
						}

						init();


					}(window, document));
				</script>
			</section>
			<section>
				<h2>イベントリスナ</h2>
				<textarea id="MultiListenerArea" readonly="readonly" cols="40" rows="5"></textarea>
				<div>
					<p>addEventListenerで同じリスナを何回追加しても1つしか追加されません。</p>
					<p>リスナ追加回数:<input id="MultiListenerSize" type="text" value="5" /></p>
					<button id="MultiListenerSample">イベント発火</button>
					<button id="ClearListenerArea">リセット</button>
				</div>
				<script>
					(function (win, doc) {

						var area = doc.getElementById("MultiListenerArea"),
							lisSiz = doc.getElementById("MultiListenerSize"),
							btn = doc.getElementById("MultiListenerSample"),
							clr = doc.getElementById("ClearListenerArea");

						function outputTime() {
							area.value += new Date().getTime() + "\n";
						}

						var listener = {
							type : "click",
							func : outputTime,
							capture : false
						};

						function getListenerSize() {
							var listenerSize = parseInt(lisSiz.value);
							return !isNaN(listenerSize) ? listenerSize : 0;
						}

						function resetListener() {
							var listenerSize = getListenerSize();

							for (var i = 0; i < listenerSize; i++) {
								btn.addEventListener(listener.type,
									listener.func, listener.capture);
							}
						}

						function clear() {
							area.value = "";

							var listenerSize = getListenerSize();

							for (var i = 0; i < listenerSize; i++) {
								btn.removeEventListener(listener.type,
									listener.func, listener.capture);
							}

							resetListener();
						}

						function init() {
							resetListener();
							clr.addEventListener("click", clear, false);
						}

						init();

					}(window, document));
				</script>
			</section>
			<section>
				<h2>配列</h2>
				<div id="ArrayResultArea">
					処理結果出力
				</div>
				<div>
					<button value="addAll" class="RunArrayFunc">addAll</button>
					<button value="sparseArray" class="RunArrayFunc">sparseArray</button>
				</div>
				<script>
					(function (win, doc) {

						var arrayNS = {},
							sampleArray = [1, 2, 3, 4, 5, 6, 7, 8, 9];

						var resArea = doc.getElementById("ArrayResultArea");

						var sampleArgs = {
							addAll : [sampleArray, ["A", "B", "C"]],
							sparseArray : [sampleArray, 5]
						};

						arrayNS.addAll = function (ary, eles) {
							Array.prototype.push.apply(ary, eles);
							return ary;
						};

						/**
						 * deleteしてもlengthは変化無し。
						 * indexの位置が疎になる。
						 */
						arrayNS.sparseArray = function (ary, index) {
							delete ary[index];
							return ary;
						};

						var runners = doc.querySelectorAll(".RunArrayFunc");
						Array.prototype.forEach.call(runners, function (el) {
							el.addEventListener("click", function () {
								var funcName = el.value,
									args = sampleArgs[funcName];
								var func = arrayNS[funcName].bind(null, args);
								resArea.innerHTML = func().join(" ");
							});
						});

					}(window, document));
				</script>
			</section>
			<section>
				<h2>部分適用</h2>
				<div id="BindResultArea">
					結果確認
				</div>
				<div>
					<button onclick="bindNS.log(bindNS.fnArray());">配列を適用</button>
					<button onclick="bindNS.log(bindNS.fnNumber());">数値を適用</button>
					<button onclick="bindNS.log(new bindNS.fnNumber(100));">コンストラクタで適用</button>
				</div>
				<script>
					(function (win, doc) {

						var bindNS = {};

						var area = doc.getElementById("BindResultArea");

						function log(txt) {
							//console.log(txt);
							area.innerHTML = txt;
						}

						/**
						 * 抽象的な関数を定義し，bindに渡す引数によって
						 * 具象的な関数を再定義する。
						 * 
						 */
						function func1(y, z) {
							return this.x + y + z;
						}

						function init() {
							bindNS.log = log;
							/* 配列は部分適用時に文字列に変換される。 */
							bindNS.fnArray = func1.bind({x : 1}, [2, 3], 10);
							bindNS.fnNumber = func1.bind({x : 1}, 2, 3);
						}

						init();

						win.bindNS = bindNS;

					}(window, document));
				</script>
			</section>
			<section>
				<h2>コンストラクタ</h2>
				<div id="ConstructorResult">
					結果確認
				</div>
				<div>
					<label>
						<input type="radio" name="inheritFuncs" value="objectNew" checked="checked" />new Object
					</label>
					<label>
						<input type="radio" name="inheritFuncs" value="objectCreate" />Object.create
					</label>
					<label>
						<input type="radio" name="inheritFuncs" value="functionBind" />Function.prototype.bind
					</label>
				</div>
				<div>
					<!-- テスト目的以外でonclickは使わないこと。 -->
					<button onclick="constructorNS.dumpSubInstance();">サブクラス生成</button>
					<button onclick="constructorNS.getSubName();">サブクラス::getName</button>
				</div>
				<script>
					(function (win, doc) {

						var resultArea = doc.getElementById("ConstructorResult");

						function display(content) {
							/**
							 * innerHTMLはサードパーティ製ライブラリとは組み合わせて
							 * 使わないこと。
							 * ライブラリによってページのDOMを勝手に編集されている場合，
							 * ライブラリが追加した要素もまとめて消してしまうなど意図しない
							 * 表示結果になることがある。
							 */
							resultArea.innerHTML = content;
						}

						function log(obj) {
							console.log(obj);
						}

						function dumpObject(obj) {
							var result = [
								"obj.constructor.name : " + obj.constructor.name
							];

							if (obj.prototype) {
								result.push("obj.prototype.constructor.name : " + obj.prototype.constructor.name);
							} else {
								result.push("obj.prototype : " + obj.prototype);
							}

							for (var prop in obj) {
								result.push(prop + " : " + obj[prop]);
							}

							display(result.join("<br />"));
						}

						function SuperClass(superName) {
							this.superName = superName;
						}

						SuperClass.prototype.getName = function () {
							return this.superName;
						};

						function SubClass(name, subName) {
							if (SubClass.superClass) {
								SubClass.superClass.call(this, name);
							}
							this.subName = subName;
						}

						/* @todo 継承できておらず呼び出されない？ */
						SubClass.prototype.getName = function () {
							var superName = SubClass.superClass.prototype.getName.apply(this, arguments);
							var subName = this.subName;

							return [superName, subName].join(" ");
						};

						function setSuperClass(superClass, subClass) {
							subClass.superClass = superClass;
						}

						function objectCreate(superClass, subClass) {
							subClass.prototype = Object.create(superClass.prototype);
						}

						function objectNew(superClass, subClass) {
							subClass.prototype = new superClass();
						}

						function functionBind(superClass, subClass) {
							/* bindが返す関数はコンストラクタではない。 */
							subClass.prototype = superClass.bind();
						}

						var inherits = {
							objectCreate : objectCreate,
							objectNew : objectNew,
							functionBind : functionBind
						};

						function doInherit(superClass, subClass) {
							var inheritFunc = null;

							var methodEles = doc.getElementsByName("inheritFuncs");
							for (var i = 0, size = methodEles.length; i < size; i++) {
								if (methodEles[i].checked) {
									inheritFunc = inherits[methodEles[i].value];
									break;
								}
							}

							if (inheritFunc) {
								inheritFunc(superClass, subClass);
								setSuperClass(superClass, subClass);
							}
						}

						function constructSubInstance(superName, subName) {
							doInherit(SuperClass, SubClass);
							var sub = new SubClass(superName, subName);
							return sub;
						}

						function dumpSubInstance() {
							var sub = constructSubInstance("Foo", "Taro");
							dumpObject(sub);
							log(sub);
						}

						function getSubName() {
							var sub = constructSubInstance("Foo", "Taro");
							display("SubName : " + sub.getName());
							log(sub);
						}

						win.constructorNS = {
							dumpSubInstance : dumpSubInstance,
							getSubName : getSubName
						};

					}(window, document));
				</script>
			</section>
			<section>
				<h2>アクセッサメソッドとオブジェクト属性</h2>
				<div>
					<textarea id="ResultAccessorArea" cols="60" rows="10"></textarea>
				</div>
				<div>
					<p><label>name<input id="InputNameAccessorValue" type="text" value="HOGE" /></label></p>
					<p><label>mode<input id="InputModeAccessorValue" type="text" value="special" /></label></p>
					<p><label>option<input id="InputOptionAccessorValue" type="text" value="ARGUMENTS" /></label></p>
					<div>
						<button onclick="accessorNS.printName();">setName→getName</button>
						<button onclick="accessorNS.printMode();">setMode→getMode</button>
						<button onclick="accessorNS.printOption();">setOption→getOption</button>
					</div>
					<div>
						<button onclick="accessorNS.dumpObject();">dump</button>
						<button onclick="accessorNS.objectMethodTest();">Object method test</button>
					</div>
					<div>
						<button onclick="document.getElementById('ResultAccessorArea').value = '';">クリア</button>
					</div>
				</div>
				<script>
					(function (win, doc) {

						var area = doc.getElementById("ResultAccessorArea"),
							inputNameEle = doc.getElementById("InputNameAccessorValue"),
							inputModeEle = doc.getElementById("InputModeAccessorValue"),
							inputOptionEle = doc.getElementById("InputOptionAccessorValue");

						function log(txt) {
							console.log(txt);
						}

						function print(txt) {
							area.value += txt + "\n";
						}

						var sample = (function () {
							/**
							 * アクセッサメソッドと異なるプロパティ名で
							 * 定義しないと再帰エラーになる。
							 */
							var _sample = {
								/* 参照されるプロパティ名は関数名と同じになる。 */
								get name() {
									print("called name getter");
									return this._name;
								},
								set name(name) {
									/**
									 * このスコープで未定義値を参照すると
									 * strictモードでなくてもエラーになる。 
									 */
									print("called name setter ... " + name);
									this._name = name;
								},
								get mode() {
									print("called mode getter");
									return this._mode;
								},
								set mode(mode) {
									print("called mode setter ... " + mode);
									this._mode = mode;
								}
							};

							/**
							 * アクセッサメソッドで参照するプロパティを
							 * 書き込み可，列挙不可，再定義不可として定義する。
							 */
							Object.defineProperties(_sample, {
								_name : {
									/**
									 * 「データプロパティ」で指定できるのは
									 * 以下の4つのプロパティである。
									 */
									value : "HOGE", writable : true, enumerable : false, configurable : false
								},
								_mode : {
									value : "normal", writable : true, enumerable : false, configurable : false
								},
								option : {
									get : function(){
										print("called option getter");
										return this._option;
									},
									set : function(option){
										print("called option setter ... " + option);
										this._option = option;
									},
									/**
									 * 「アクセッサプロパティ」でget, set以外に
									 * 指定できるのはenumerabelとconfigurableのみ。
									 * writableやvalueを指定するとエラーになる。
									 */
									enumerable : false, configurable : false
								}
							});

							return _sample;
						}());

						function objectMethodTest(){
							/**
							 * Object.create(null)で生成したオブジェクトは
							 * prototypeプロパティを持たないので
							 * in演算子でプロパティの列挙を行う際にhasOwnProperty
							 * によるチェックを行う必要が無い。
							 * enumerableがfalseだと当然そのプロパティは
							 * 列挙されなくなる。
							 * オブジェクトリテラルによる擬似配列のlengthを
							 * 要素の列挙前に削除することがあったが，enumerableを
							 * falseにすればよかっただけである。
							 */
							var obj0 = Object.create(null);
							Object.defineProperty(obj0, "name", {
								value : "not writable and not configurable object0",
								writable : false,
								enumerable : true,
								configurable : false
							});
							
							/**
							 * writableがtrueであること以外はobj0, obj1と同じ
							 * オブジェクト属性になる。
							 */
							var obj1 = Object.create(null);
							obj1.name = "seal object1";
							Object.seal(obj1);
							
							/**
							 * obj0と同じオブジェクト属性になる。
							 */
							var obj2 = Object.create(null);
							obj2.name = "freeze object2";
							Object.freeze(obj2);
							
							var objs = [obj0, obj1, obj2];
							
							objs.forEach(function(o){
								log(o);
								/**
								 * オブジェクトがオブジェクトリテラルや
								 * コンストラクタ関数で生成された時に
								 * オブジェクトのプロパティを列挙する場合は，
								 * Object.keysを使えば継承されたプロパティが
								 * 列挙されないため安全である。
								 */
								Object.keys(o).forEach(function(k){
									print(k + " → " + o[k]);
									var desc = Object.getOwnPropertyDescriptor(o, k);
									Object.keys(desc).forEach(function(d){
										print(d + " : " + desc[d]);
									});
								});
								//for(var prop in o){
								//	print(o[prop]);
								//}
							});
						}
						
						function init() {
						}

						init();

						win.accessorNS = {
							printName : function () {
								sample.name = inputNameEle.value;
								print(sample.name);
							},
							printMode : function () {
								sample.mode = inputModeEle.value;
								print(sample.mode);
							},
							printOption : function () {
								sample.option = inputOptionEle.value;
								print(sample.option);
							},
							dumpObject : function(){
								/* 各プロパティのgetterが2回ずつ呼び出される。 */
								log(sample);
								/* 以下は無視される。 */
								delete sample._name;
								delete sample._mode;
								delete sample.option;
							},
							objectMethodTest : objectMethodTest
						};

					}(window, document));
				</script>
			</section>
		</main>

		<footer role="contentinfo">
			<small>Copyright &copy; 2014 moguonyanko All rights reserved.</small>
		</footer>
	</body>
</html>
