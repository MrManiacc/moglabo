<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta charset="UTF-8" />
		<title>JavaScript(Core and Client)</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="shortcut icon" href="../favicon.ico" />
		<style>
			section {
				margin: 2px;
				padding: 3px;
				border: 1px solid lightgrey;
				border-radius: 5px;
			}
		</style>
		<script>
			(function(win) {
				"use strict";

				win.commonNS = win.my = {
					log : function() {
						console.log.apply(null, arguments);
					},
					println : function(ele, txt, override) {
						var prop;

						if ("value" in ele) {
							prop = "value";
						} else {
							prop = "innerHTML";
						}

						if (override) {
							ele[prop] = txt + "\n";
						} else {
							ele[prop] += txt + "\n";
						}
					},
					ref : function(id, doc) {
						/* @todo contentDocumentを使うべき？ */
						return (doc || document).getElementById(id);
					},
					refs : function(name, doc) {
						/**
						 * デフォルト値としては配列ではなくNodeListを返すべき。 
						 * しかしNodeListのコンストラクタは呼び出せない。
						 * 空のNodeListを意図的に返すにはどうすればよいか？
						 */
						return (doc || document).getElementsByName(name) || [];
					},
					export : function(name, ns){
						win[name] = ns;
					}
				};

			}(window));
		</script>
	</head>
	<body>
		<header role="banner">
			<h1>JavaScript(Core and Client)</h1>
			<p>コア及びクライアントサイドのJavaScriptの練習サイトです。</p>
		</header>

	<main>
		<section>
			<h2>クロージャ</h2>
			<section>
				<h3>thisの扱い</h3>
				<button class="ClosureButton">0</button>
				<button class="ClosureButton">0</button>
				<button class="ClosureButton">0</button>
				<script>
					(function(doc) {
						"use strict";

						var btns = doc.querySelectorAll(".ClosureButton");

						for (var i = 0; i < btns.length; i++) {
							btns[i].onclick = (function(x) {
								return function() {
									this.innerHTML = x + 1;
								};
							}(i));

//								btns[i].onclick = (function (x, that) {
//									return function () {
//										that.innerHTML = x + 1;
//									};
//								}(i, btns[i]));
						}
					}(document));
				</script>
			</section>
		</section>
		<section>
			<style scoped="scoped">
				.NewClass {
					color: red;
					font-weight: bold;
					/*font-size: 150%;*/
				}
			</style>
			<h2>クラスリスト</h2>
			<p id="ClassListSampleElement" class="Hoge Foo Bar">サンプル</p>
			<button id="ToggleClass">Toggle class</button>
			<textarea id="ClassListResult" readonly="readonly" cols="40" rows="5">
			</textarea>
			<script>
				(function(win, doc) {
					"use strict";

					var sample = doc.getElementById("ClassListSampleElement"),
						sampleClass = "NewClass",
						toggler = doc.getElementById("ToggleClass"),
						result = doc.getElementById("ClassListResult");

					function addEvent(ele, type, fn, cap) {
						ele.addEventListener(type, fn, cap);
					}

					function init() {
						result.value = "";

						sample.classList.add(sampleClass);

						for (var i = 0; i < sample.classList.length; i++) {
							result.value += sample.classList[i];
							result.value += "\n";
						}

						addEvent(toggler, "click", function() {
							sample.classList.toggle(sampleClass);
						});

						setTimeout(function() {
							sample.classList.remove(sampleClass);
						}, 3000);
					}

					init();


				}(window, document));
			</script>
		</section>
		<section>
			<h2>イベントリスナ</h2>
			<textarea id="MultiListenerArea" readonly="readonly" cols="40" rows="5"></textarea>
			<div>
				<p>addEventListenerで同じリスナを何回追加しても1つしか追加されません。</p>
				<p>リスナ追加回数:<input id="MultiListenerSize" type="text" value="5" /></p>
				<button id="MultiListenerSample">イベント発火</button>
				<button id="ClearListenerArea">リセット</button>
			</div>
			<script>
				(function(win, doc) {
					"use strict";

					var area = doc.getElementById("MultiListenerArea"),
						lisSiz = doc.getElementById("MultiListenerSize"),
						btn = doc.getElementById("MultiListenerSample"),
						clr = doc.getElementById("ClearListenerArea");

					function outputTime() {
						area.value += new Date().getTime() + "\n";
					}

					var listener = {
						type : "click",
						func : outputTime,
						capture : false
					};

					function getListenerSize() {
						var listenerSize = parseInt(lisSiz.value);
						return !isNaN(listenerSize) ? listenerSize : 0;
					}

					function resetListener() {
						var listenerSize = getListenerSize();

						for (var i = 0; i < listenerSize; i++) {
							btn.addEventListener(listener.type,
								listener.func, listener.capture);
						}
					}

					function clear() {
						area.value = "";

						var listenerSize = getListenerSize();

						for (var i = 0; i < listenerSize; i++) {
							btn.removeEventListener(listener.type,
								listener.func, listener.capture);
						}

						resetListener();
					}

					function init() {
						resetListener();
						clr.addEventListener("click", clear, false);
					}

					init();

				}(window, document));
			</script>
		</section>
		<section>
			<h2>配列</h2>
			<div id="ArrayResultArea">
				処理結果出力
			</div>
			<div>
				<button value="addAll" class="RunArrayFunc">addAll</button>
				<button value="sparseArray" class="RunArrayFunc">sparseArray</button>
			</div>
			<script>
				(function(win, doc) {
					"use strict";

					var arrayNS = {},
						sampleArray = [1, 2, 3, 4, 5, 6, 7, 8, 9];

					var resArea = doc.getElementById("ArrayResultArea");

					var sampleArgs = {
						addAll : [sampleArray, ["A", "B", "C"]],
						sparseArray : [sampleArray, 5]
					};

					arrayNS.addAll = function(ary, eles) {
						Array.prototype.push.apply(ary, eles);
						return ary;
					};

					/**
					 * deleteしてもlengthは変化無し。
					 * indexの位置が疎になる。
					 */
					arrayNS.sparseArray = function(ary, index) {
						delete ary[index];
						return ary;
					};

					var runners = doc.querySelectorAll(".RunArrayFunc");
					Array.prototype.forEach.call(runners, function(el) {
						el.addEventListener("click", function() {
							var funcName = el.value,
								args = sampleArgs[funcName];
							var func = arrayNS[funcName].bind(null, args);
							resArea.innerHTML = func().join(" ");
						});
					});

				}(window, document));
			</script>
		</section>
		<section>
			<h2>部分適用</h2>
			<div id="BindResultArea">
				結果確認
			</div>
			<div>
				<button onclick="bindNS.log(bindNS.fnArray());">配列を適用</button>
				<button onclick="bindNS.log(bindNS.fnNumber());">数値を適用</button>
				<button onclick="bindNS.log(new bindNS.fnNumber(100));">コンストラクタで適用</button>
			</div>
			<script>
				(function(win, doc) {
					"use strict";

					var bindNS = {};

					var area = doc.getElementById("BindResultArea");

					function log(txt) {
						//console.log(txt);
						area.innerHTML = txt;
					}

					/**
					 * 抽象的な関数を定義し，bindに渡す引数によって
					 * 具象的な関数を再定義する。
					 * 
					 */
					function func1(y, z) {
						return this.x + y + z;
					}

					function init() {
						bindNS.log = log;
						/* 配列は部分適用時に文字列に変換される。 */
						bindNS.fnArray = func1.bind({x : 1}, [2, 3], 10);
						bindNS.fnNumber = func1.bind({x : 1}, 2, 3);
					}

					init();

					win.bindNS = bindNS;

				}(window, document));
			</script>
		</section>
		<section>
			<h2>コンストラクタ</h2>
			<div id="ConstructorResult">
				結果確認
			</div>
			<div>
				<label>
					<input type="radio" name="inheritFuncs" value="objectNew" checked="checked" />new Object
				</label>
				<label>
					<input type="radio" name="inheritFuncs" value="objectCreate" />Object.create
				</label>
				<label>
					<input type="radio" name="inheritFuncs" value="functionBind" />Function.prototype.bind
				</label>
			</div>
			<div>
				<!-- テスト目的以外でonclickは使わないこと。 -->
				<button onclick="constructorNS.dumpSubInstance();">サブクラス生成</button>
				<button onclick="constructorNS.getSubName();">サブクラス::getName</button>
			</div>
			<script>
				(function(win, doc) {
					"use strict";

					var resultArea = doc.getElementById("ConstructorResult");

					function display(content) {
						/**
						 * innerHTMLはサードパーティ製ライブラリとは組み合わせて
						 * 使わないこと。
						 * ライブラリによってページのDOMを勝手に編集されている場合，
						 * ライブラリが追加した要素もまとめて消してしまうなど意図しない
						 * 表示結果になることがある。
						 */
						resultArea.innerHTML = content;
					}

					function log(obj) {
						console.log(obj);
					}

					function dumpObject(obj) {
						var result = [
							"obj.constructor.name : " + obj.constructor.name
						];

						if (obj.prototype) {
							result.push("obj.prototype.constructor.name : " + obj.prototype.constructor.name);
						} else {
							result.push("obj.prototype : " + obj.prototype);
						}

						for (var prop in obj) {
							result.push(prop + " : " + obj[prop]);
						}

						display(result.join("<br />"));
					}

					function SuperClass(superName) {
						this.superName = superName;
					}

					SuperClass.prototype.getName = function() {
						return this.superName;
					};

					function SubClass(name, subName) {
						if (SubClass.superClass) {
							SubClass.superClass.call(this, name);
						}
						this.subName = subName;
					}

					/* @todo 継承できておらず呼び出されない？ */
					SubClass.prototype.getName = function() {
						var superName = SubClass.superClass.prototype.getName.apply(this, arguments);
						var subName = this.subName;

						return [superName, subName].join(" ");
					};

					function setSuperClass(superClass, subClass) {
						subClass.superClass = superClass;
					}

					function objectCreate(superClass, subClass) {
						subClass.prototype = Object.create(superClass.prototype);
					}

					function objectNew(superClass, subClass) {
						subClass.prototype = new superClass();
					}

					function functionBind(superClass, subClass) {
						/* bindが返す関数はコンストラクタではない。 */
						subClass.prototype = superClass.bind();
					}

					var inherits = {
						objectCreate : objectCreate,
						objectNew : objectNew,
						functionBind : functionBind
					};

					function doInherit(superClass, subClass) {
						var inheritFunc = null;

						var methodEles = doc.getElementsByName("inheritFuncs");
						for (var i = 0, size = methodEles.length; i < size; i++) {
							if (methodEles[i].checked) {
								inheritFunc = inherits[methodEles[i].value];
								break;
							}
						}

						if (inheritFunc) {
							inheritFunc(superClass, subClass);
							setSuperClass(superClass, subClass);
						}
					}

					function constructSubInstance(superName, subName) {
						doInherit(SuperClass, SubClass);
						var sub = new SubClass(superName, subName);
						return sub;
					}

					function dumpSubInstance() {
						var sub = constructSubInstance("Foo", "Taro");
						dumpObject(sub);
						log(sub);
					}

					function getSubName() {
						var sub = constructSubInstance("Foo", "Taro");
						display("SubName : " + sub.getName());
						log(sub);
					}

					win.constructorNS = {
						dumpSubInstance : dumpSubInstance,
						getSubName : getSubName
					};

				}(window, document));
			</script>
		</section>
		<section>
			<h2>アクセッサメソッドとオブジェクト属性</h2>
			<div>
				<textarea id="ResultAccessorArea" cols="60" rows="10"></textarea>
			</div>
			<div>
				<p><label>name<input id="InputNameAccessorValue" type="text" value="HOGE" /></label></p>
				<p><label>mode<input id="InputModeAccessorValue" type="text" value="special" /></label></p>
				<p><label>option<input id="InputOptionAccessorValue" type="text" value="ARGUMENTS" /></label></p>
				<div>
					<button onclick="accessorNS.printName();">setName→getName</button>
					<button onclick="accessorNS.printMode();">setMode→getMode</button>
					<button onclick="accessorNS.printOption();">setOption→getOption</button>
				</div>
				<div>
					<button onclick="accessorNS.dumpObject();">dump</button>
					<button onclick="accessorNS.objectMethodTest();">Object method test</button>
				</div>
				<div>
					<button onclick="document.getElementById('ResultAccessorArea').value = '';">クリア</button>
				</div>
			</div>
			<script>
				(function(win, doc) {
					"use strict";

					var area = doc.getElementById("ResultAccessorArea"),
						inputNameEle = doc.getElementById("InputNameAccessorValue"),
						inputModeEle = doc.getElementById("InputModeAccessorValue"),
						inputOptionEle = doc.getElementById("InputOptionAccessorValue");

					function log(txt) {
						console.log(txt);
					}

					function print(txt) {
						area.value += txt + "\n";
					}

					var sample = (function() {
						/**
						 * アクセッサメソッドと異なるプロパティ名で
						 * 定義しないと再帰エラーになる。
						 */
						var _sample = {
							/* 参照されるプロパティ名は関数名と同じになる。 */
							get name() {
								print("called name getter");
								return this._name;
							},
							set name(name) {
								/**
								 * このスコープで未定義値を参照すると
								 * strictモードでなくてもエラーになる。 
								 */
								print("called name setter ... " + name);
								this._name = name;
							},
							get mode() {
								print("called mode getter");
								return this._mode;
							},
							set mode(mode) {
								print("called mode setter ... " + mode);
								this._mode = mode;
							}
						};

						/**
						 * アクセッサメソッドで参照するプロパティを
						 * 書き込み可，列挙不可，再定義不可として定義する。
						 */
						Object.defineProperties(_sample, {
							_name : {
								/**
								 * 「データプロパティ」で指定できるのは
								 * 以下の4つのプロパティである。
								 */
								value : "HOGE", writable : true, enumerable : false, configurable : false
							},
							_mode : {
								value : "normal", writable : true, enumerable : false, configurable : false
							},
							option : {
								get : function() {
									print("called option getter");
									return this._option;
								},
								set : function(option) {
									print("called option setter ... " + option);
									this._option = option;
								},
								/**
								 * 「アクセッサプロパティ」でget, set以外に
								 * 指定できるのはenumerabelとconfigurableのみ。
								 * writableやvalueを指定するとエラーになる。
								 */
								enumerable : false, configurable : false
							}
						});

						return _sample;
					}());

					function objectMethodTest() {
						/**
						 * Object.create(null)で生成したオブジェクトは
						 * prototypeプロパティを持たないので
						 * in演算子でプロパティの列挙を行う際にhasOwnProperty
						 * によるチェックを行う必要が無い。
						 * enumerableがfalseだと当然そのプロパティは
						 * 列挙されなくなる。
						 * オブジェクトリテラルによる擬似配列のlengthを
						 * 要素の列挙前に削除することがあったが，enumerableを
						 * falseにすればよかっただけである。
						 */
						var obj0 = Object.create(null);
						Object.defineProperty(obj0, "name", {
							value : "not writable and not configurable object0",
							writable : false,
							enumerable : true,
							configurable : false
						});

						/**
						 * writableがtrueであること以外はobj0, obj1と同じ
						 * オブジェクト属性になる。
						 */
						var obj1 = Object.create(null);
						obj1.name = "seal object1";
						Object.seal(obj1);

						/**
						 * obj0と同じオブジェクト属性になる。
						 */
						var obj2 = Object.create(null);
						obj2.name = "freeze object2";
						Object.freeze(obj2);

						var objs = [obj0, obj1, obj2];

						objs.forEach(function(o) {
							log(o);
							/**
							 * オブジェクトがオブジェクトリテラルや
							 * コンストラクタ関数で生成された時に
							 * オブジェクトのプロパティを列挙する場合は，
							 * Object.keysを使えば継承されたプロパティが
							 * 列挙されないため安全である。
							 */
							Object.keys(o).forEach(function(k) {
								print(k + " → " + o[k]);
								var desc = Object.getOwnPropertyDescriptor(o, k);
								Object.keys(desc).forEach(function(d) {
									print(d + " : " + desc[d]);
								});
							});
							//for(var prop in o){
							//	print(o[prop]);
							//}
						});
					}

					function init() {
					}

					init();

					win.accessorNS = {
						printName : function() {
							sample.name = inputNameEle.value;
							print(sample.name);
						},
						printMode : function() {
							sample.mode = inputModeEle.value;
							print(sample.mode);
						},
						printOption : function() {
							sample.option = inputOptionEle.value;
							print(sample.option);
						},
						dumpObject : function() {
							/* 各プロパティのgetterが2回ずつ呼び出される。 */
							log(sample);
							/* 以下は無視される。 */
							delete sample._name;
							delete sample._mode;
							delete sample.option;
						},
						objectMethodTest : objectMethodTest
					};

				}(window, document));
			</script>
		</section>
		<section>
			<style scoped="scoped">
				.InnerFrameContainer {
					border: 1px solid black;
					border-radius: 5px;
				}
			</style>
			<h2>複数のウインドウとフレーム</h2>
			<div>
				<p>テストフレーム</p>
				<div class="InnerFrameContainer">
					<iframe id="SubInnerFrame0" src="sub0.html" name="sub0" width="300" height="100"></iframe>
					<!-- width, heightに%指定できるのはHTML5以降 -->
					<!--<iframe id="SubInnerFrame0" src="sub0.html" name="sub0" width="100%" height="100%"></iframe>-->
				</div>
				<div class="InnerFrameContainer">
					<iframe id="SubInnerFrame1" src="sub1.html" name="sub1" width="300" height="100"></iframe>
					<!--<iframe id="SubInnerFrame1" src="sub1.html" name="sub1" width="100%" height="100%"></iframe>-->
				</div>
			</div>
			<div>
				<textarea id="ResultInnerFrameArea" cols="60" rows="10"></textarea>
			</div>
			<div>
				<button onclick="frameNS.dumpFrames();">iframe情報一覧</button>
				<button onclick="frameNS.openWindows();">開いたウインドウの調査</button>
				<button onclick="frameNS.checkInstanceViaFrames();">フレーム毎のインスタンス調査</button>
				<button onclick="frameNS.displaySubContainer();">サブウインドウの要素取得</button>
			</div>
			<div>
				<button onclick="document.getElementById('ResultInnerFrameArea').value = '';">クリア</button>
			</div>
			<script>
				(function(win, doc) {
					"use strict";

					var area = doc.getElementById("ResultInnerFrameArea");

					var sample = [1, 2, 3, 4, 5],
						sampleConstructor = Array;
						
					var subWin0;

					function println(txt) {
						my.log(frames);
						area.value += txt + "\n";
					}

					function dumpFrames() {
						var frames = win.frames;

						Array.prototype.forEach.call(frames, function(frm, i) {
							/**
							 * 後ろの===は先に書かれた+に優先度で負けるので，
							 * 意図した結果を得るには()で囲む必要がある。 
							 */
							println("frames[" + frm.name + "] === frames[" + i + "] ... " + (frm === frames[i]));

							/* src属性を使ってquerySelectorするのは許されない？エラーになる。 */
							//var frmEle = doc.querySelector(".InnerFrameContainer iframe[src=" + frm.name + ".html]");
							var frmEle = doc.getElementById("SubInnerFrame" + i);
							println("iframe.contentWindow === iframe ... " + (frmEle.contentWindow === frm));
						});
					}

					function openWindows() {
						var style = "width=400,height=300,status=yes,resizable=yes",
							replaceHistory = true;

						/**
						 * 同一ページを読み込んだiframeがDOMツリー上に存在する時は
						 * そのページをwindow.openで開くことができない。
						 * openの戻り値(Windowオブジェクト)は得られる。
						 */
						var w0 = win.open("sub0.html", "sub0", style, replaceHistory);
						var w1 = win.open("sub1.html", "sub1", style, replaceHistory);

						println("w0.opener === window ... " + (w0.opener === win));
						println("w1.opener === window ... " + (w1.opener === win));
					}

					function checkInstance() {
						return sample instanceof sampleConstructor;
					}

					function checkInstanceOf(obj) {
						return obj instanceof sampleConstructor;
					}

					/**
					 * フレームをまたいだ状態でオブジェクトの型を調べる。
					 * instanceof の挙動を調べる。
					 */
					function checkInstanceViaFrames() {
						var frames = win.frames;

						var frm0 = frames.sub0,
							frm1 = frames.sub1;

						my.println(area, checkInstance());
						my.println(area, frm0.sub0NS.checkInstance());
						my.println(area, frm1.sub1NS.checkInstance());

						/**
						 * 別のフレームのオブジェクトをinstanceofで型チェックしても
						 * 予想した結果は得られない。Arrayのような組み込みオブジェクト
						 * であってもフレームが異なれば異なるインスタンスとして
						 * 扱われてしまう。
						 */
						my.println(area, checkInstanceOf(frm0.sub0NS.getArray()));
						my.println(area, checkInstanceOf(frm1.sub1NS.getArray()));
					}

					function init() {
						//subWin0 = win.open("sub0.html");
					}

					win.frameNS = {
						dumpFrames : dumpFrames,
						openWindows : openWindows,
						checkInstanceViaFrames : checkInstanceViaFrames,
						displaySubContainer : function(){
							var container = win.frames.sub1.sub1NS.getContainer();
							my.println(area, container);
						}
					};
					
					init();

				}(window, document));
			</script>
		</section>
		<section>
			<style scoped="scoped">
			</style>
			<h2>データ型</h2>
			<div>
				<textarea id="ResultDataTypeArea" cols="60" rows="10"></textarea>
			</div>
			<div>
				<button id="InstanceChecker">instanceofによる型の確認</button>
			</div>
			<div>
				<button onclick="my.ref('ResultDataTypeArea').value = '';">クリア</button>
			</div>
			<script>
				(function(win, doc) {
					"use strict";

					var resultArea = my.ref("ResultDataTypeArea"),
						typeChecker = my.ref("InstanceChecker");

					function checkInstance() {
						/**
						 * +演算子がinstanceof演算子より先に評価されないように
						 * instanceof演算子の式を()で囲むことは必須。
						 */
						var result = [
							"1 instanceof Number ... " + (1 instanceof Number),
							"Number(1) instanceof Number ... " + (Number(1) instanceof Number),
							"new Number(1) instanceof Number ... " + (new Number(1) instanceof Number),
							"\"\" instanceof String ... " + ("" instanceof String),
							"String(\"\") instanceof String ... " + (String("") instanceof String),
							"new String(\"\") instanceof String ... " + (new String("") instanceof String)
						];

						return result.join("\n");
					}

					function init() {
						typeChecker.addEventListener("click", function() {
							var checkResult = checkInstance();
							my.println(resultArea, checkResult);
						}, false);
					}

					init();

				}(window, document));
			</script>
		</section>
		<section>
			<style scoped="scoped">
			</style>
			<h2>正規表現</h2>
			<div>
				<textarea id="RegExpResultArea" cols="60" rows="10"></textarea>
			</div>
			<div>
				<label for="RegExpSampleValue">サンプル文字列</label>
				<span><input id="RegExpSampleValue" type="text" value="JavaScript Lisp Java Python" /></span>
				<label for="RegExpSamplePattern">パターン</label>
				<span><input id="RegExpSamplePattern" type="text" value="java" /></span>
				<div>
					<span>フラグ</span>
					<label><input type="checkbox" name="RegExpSampleFlag" value="g" checked="checked" />global</label>
					<label><input type="checkbox" name="RegExpSampleFlag" value="i" checked="checked" />ignoreCase</label>
					<label><input type="checkbox" name="RegExpSampleFlag" value="m" checked="checked" />multiline</label>
				</div>
			</div>
			<div>
				<button onclick="regexpNS.match();">String::match</button>
				<button onclick="regexpNS.split();">String::split</button>
			</div>
			<div>
				<button onclick="my.ref('RegExpResultArea').value = '';">クリア</button>
			</div>
			<script>
				(function(win, doc) {
					"use strict";

					var area = my.ref("RegExpResultArea"),
						sampleValueEle = my.ref("RegExpSampleValue"),
						samplePatternEle = my.ref("RegExpSamplePattern"),
						sampleFlagEles = my.refs("RegExpSampleFlag");

					function getFlag() {
						var results = Array.prototype.map.call(
							sampleFlagEles,
							function(ele) {
								if (ele.checked) {
									return ele.value;
								} else {
									return "";
								}
							});

						return results.join("");
					}

					function getPattern(opt_flag) {
						var flag = opt_flag || getFlag();
						return new RegExp(samplePatternEle.value, flag);
					}

					function getValue() {
						return sampleValueEle.value;
					}

					function match(value, pattern) {
						return value.match(pattern);
					}

					function split(value, pattern) {
						return value.split(pattern);
					}

					win.regexpNS = {
						match : function() {
							var res = match(getValue(), getPattern());
							my.log(res);
							my.println(area, res);
						},
						split : function() {
							var res = split(getValue(), getPattern());
							my.log(res);
							my.println(area, res);
						}
					};

				}(window, document));
			</script>
		</section>
		<section>
			<style scoped="scoped">
				.DataTransformRow {
					padding: 3px;
					border: lightgrey 1px solid;
					border-radius: 5px;
				}

				.DataTransformResult {
					font-weight: bold;
					border-bottom: solid 1px black;
				}

				.FormulaSummary {
					width: 75%;
				}
			</style>
			<h2>演算子と型変換</h2>
			<div class="FormulaContainer">
				<p class="FormulaSummary">
					二項演算子の+演算子はオペランドの型の異なる場合<strong>文字列</strong>に変換して揃える。<br />
					即ちオペランドのどれかが文字列であればもう一方のオペランドも文字列に変換される。
				</p>
				<p class="DataTransformRow">x = "1" + 1;<br />
					x = <span id="DataTransformResult0" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = 1 + "1";<br />
					x = <span id="DataTransformResult1" class="DataTransformResult"></span></p>

				<p class="FormulaSummary">
					単項算術演算子はオペランドを数値に変換する。<br />
					インクリメント，デクリメントでも必ず数値へ変換される。<br />
					nullやtrue, false，文字列など数値でない値はそのままインクリメントすると
					エラーになってしまうが，一度別の変数に代入すればインクリメントできる。<br />
					デクリメントも同様の振る舞いを示す。
				</p>
				<p class="DataTransformRow">x = "1";<br />x++;<br />
					x = <span id="DataTransformResult2" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = null;<br />x++;<br />
					x = <span id="DataTransformResult20" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = null;<br />
					+x; //<span id="DataTransformResult27" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = null;<br />
					-x; //<span id="DataTransformResult28" class="DataTransformResult"></span></p>

				<p class="FormulaSummary">
					論理値やnullも<strong>文字列変換されない状況では</strong>数値に変換される。<br />
					trueは1，falseとnullは0に変換される。
				</p>
				<p class="DataTransformRow">x = true + false + null;<br />
					x = <span id="DataTransformResult3" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = true + "false" + null;<br />
					x = <span id="DataTransformResult4" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = Math.pow(null, false);<br />
					x = <span id="DataTransformResult11" class="DataTransformResult"></span></p>

				<p class="FormulaSummary">
					undefinedはNaNに変換される。NaNが1つでも含まれている式の結果はNaNになる。
				</p>
				<p class="DataTransformRow">x = 1 + undefined;<br />
					x = <span id="DataTransformResult5" class="DataTransformResult"></span></p>

				<p class="FormulaSummary">
					JavaScriptの数値は全て浮動小数点数である。
					計算結果が自動的に切り捨て切り上げされて整数になったりしない。<br />
					整数のように見えても整数ではない(と考えるのが安全)。
				</p>
				<p class="DataTransformRow">x = 5 / 2;<br />
					x = <span id="DataTransformResult6" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = 6.3 / 2.1;<br />
					x = <span id="DataTransformResult7" class="DataTransformResult"></span></p>

				<p class="FormulaSummary">
					%演算子は小数に対しても動作する。結果の符号は最初のオペランドと同じになる。
				</p>
				<p class="DataTransformRow">x = 6.5 % -2.1;<br />
					x = <span id="DataTransformResult8" class="DataTransformResult"></span></p>

				<p class="FormulaSummary">
					オペランドのオブジェクトがvalueOfを実装していればその戻り値を使って計算を行う。<br />
					valueOfが実装されていなければオブジェクトはtoStringを使って文字列変換される。
				</p>
				<p class="DataTransformRow">x = new Sample() + 1;<br />
					x = <span id="DataTransformResult9" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = new Sample2() + 1;<br />
					x = <span id="DataTransformResult10" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = [] + 1;<br />
					x = <span id="DataTransformResult12" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = [9] + 1;<br />
					x = <span id="DataTransformResult13" class="DataTransformResult"></span></p>

				<p class="FormulaSummary">
					空文字と配列の変換は変換を行う関数によって結果が異なる。
				</p>
				<p class="DataTransformRow">x = Number("");<br />
					x = <span id="DataTransformResult14" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = parseInt("");<br />
					x = <span id="DataTransformResult15" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = Number([]);<br />
					x = <span id="DataTransformResult16" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = parseInt([]);<br />
					x = <span id="DataTransformResult17" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = Number([1]);<br />
					x = <span id="DataTransformResult18" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = Number([1,2]);<br />
					x = <span id="DataTransformResult19" class="DataTransformResult"></span></p>

				<p class="FormulaSummary">
					-演算子はオペランドの型の異なる場合<strong>数値</strong>に変換して揃える。<br />
					数値にならない値はNaNに変換される。<br />
					*演算子と/演算子も-演算子と同じように振る舞う。+演算子だけが文字列変換を優先する。
				</p>
				<p class="DataTransformRow">x = 1;<br />y = "1";<br />
					x - y = <span id="DataTransformResult23" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = 1;<br />y = "one";<br />
					x - y = <span id="DataTransformResult24" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = 2;<br />y = "2";<br />
					x * y = <span id="DataTransformResult25" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = 2;<br />y = "2";<br />
					x / y = <span id="DataTransformResult26" class="DataTransformResult"></span></p>

				<p class="FormulaSummary">
					等値演算子(==)はオペランドの型の異なる場合<strong>数値</strong>に変換して揃える。<br />
					比較演算子も同様に振る舞う。
				</p>
				<p class="DataTransformRow">x = 1;<br />y = "1";<br />
					x == y; //<span id="DataTransformResult21" class="DataTransformResult"></span></p>
				<p class="DataTransformRow">x = 1;<br />y = "2";<br />
					x $gt; y; //<span id="DataTransformResult22" class="DataTransformResult"></span></p>
			</div>
			<script>
				(function(win, doc) {
					"use strict";

					function Sample() {
						this.value = 100;
					}

					Sample.prototype = {
						toString : function() {
							return "&lt;toString is not called if valueOf exists&gt;";
						},
						valueOf : function() {
							return this.value;
						}
					};

					function Sample2() {
					}

					Sample2.prototype = {
						toString : function() {
							return "&lt;valueOf is not implemented&gt;";
						}
					};

					function setValue(id, val) {
						my.ref(id).innerHTML = val;
					}

					var formulas = {
						DataTransformResult0 : function() {
							return "1" + 1;
						},
						DataTransformResult1 : function() {
							return 1 + "1";
						},
						DataTransformResult2 : function() {
							var x = "1";
							x++;
							return x;
						},
						DataTransformResult3 : function() {
							return true + false + null;
						},
						DataTransformResult4 : function() {
							return true + "false" + null;
						},
						DataTransformResult11 : function() {
							return Math.pow(null, false);
						},
						DataTransformResult5 : function() {
							return 1 + undefined;
						},
						DataTransformResult6 : function() {
							return 5 / 2;
						},
						DataTransformResult7 : function() {
							return 6.3 / 2.1;
						},
						DataTransformResult8 : function() {
							return 6.5 % -2.1;
						},
						DataTransformResult9 : function() {
							return new Sample() + 1;
						},
						DataTransformResult10 : function() {
							return new Sample2() + 1;
						},
						DataTransformResult12 : function() {
							return [] + 1;
						},
						DataTransformResult13 : function() {
							return [9] + 1;
						},
						DataTransformResult14 : function() {
							return Number("");
						},
						DataTransformResult15 : function() {
							return parseInt("");
						},
						DataTransformResult16 : function() {
							return Number([]);
						},
						DataTransformResult17 : function() {
							return parseInt([]);
						},
						DataTransformResult18 : function() {
							return Number([1]);
						},
						DataTransformResult19 : function() {
							return Number([1, 2]);
						},
						DataTransformResult20 : function() {
							var x = null;
							x++;
							return x;
						},
						DataTransformResult21 : function() {
							var x = 1,
								y = "1";

							return x == y;
						},
						DataTransformResult22 : function() {
							var x = 1,
								y = "2";

							return x < y;
						},
						DataTransformResult23 : function() {
							var x = 1,
								y = "1";

							return x - y;
						},
						DataTransformResult24 : function() {
							var x = 1,
								y = "one";

							return x - y;
						},
						DataTransformResult25 : function() {
							var x = 2,
								y = "2";

							return x * y;
						},
						DataTransformResult26 : function() {
							var x = 2,
								y = "2";

							return x / y;
						},
						DataTransformResult27 : function() {
							var x = null;

							return +x;
						},
						DataTransformResult28 : function() {
							var x = null;

							return -x;
						}
					};

					function setupFormulas() {
						for (var name in formulas) {
							var result = formulas[name]();
							setValue(name, result);
						}
					}

					function init() {
						setupFormulas();
					}

					init();

				}(window, document));
			</script>
		</section>
		<section>
			<style scoped="">
				#NowModeInfo {
					border-bottom: solid 1px black;
					text-align: center;
				}
			</style>
			<h2>eval</h2>
			<div>
				<p id="NowModeInfo"></p>
				<div>
					<p>グローバルevalを使うための準備</p>
					<pre>
var globalEval = eval;						
					</pre>
					<p>グローバル変数</p>
					<pre>
x = "x not changed";
y = "y not changed";
					</pre>
				</div>
				<div>
					<h3>直接eval</h3>
					<pre>
function direct(){
	var x = "local x not changed";
	eval("x = \"x changed!\";");
	return x;
}
					</pre>
					<div id="DirectEvalResultArea">評価結果</div>
					<button onclick="evalNS.direct();">評価</button>
				</div>
				<div>
					<h3>グローバルeval</h3>
					<pre>
function indirect(){
	var y = "local y not changed";
	globalEval("y = \"y changed!\";");
	return y;
}
					</pre>
					<div id="IndirectEvalResultArea">評価結果</div>
					<button onclick="evalNS.indirect();">評価</button>
				</div>
			</div>
			<script>
				(function nostrict(win, doc) {
					var globalEval = eval;
					
					function initGlobalValue(){
						/* strictモードでは以下の行はエラーになる。 */
						x = "x not changed";
						y = "y not changed";
					}

					function direct() {
						var x = "local x not changed";
						eval("x = \"<strong>x changed!</strong>\";");
						return x;
					}

					function indirect() {
						var y = "local y not changed";
						/* グローバル変数を変更してしまうeval */
						globalEval("y = \"<strong>y changed!</strong>\";");
						/* 戻り値はローカル変数の値になる。 */
						return y;
					}

					function display(id, fn) {
						var res = fn();
						
						var results = [
							res,
							/* グローバル変数が変更されているかを確認する。 */
							"global x=" + x + ", global y=" + y + ""
						];
						
						var info = results.join(":");
						
						my.log(info);
						my.println(my.ref(id), info, true);
						initGlobalValue();
					}

					function isStrict(){
						return this === undefined;
					}

					function init() {
						var info = my.ref("NowModeInfo");
						
						if(isStrict()){
							my.println(info, "strictモードで実行中");
						}else{
							my.println(info, "非strictモードで実行中");
						}
						
						initGlobalValue();
					}

					init();

					win.evalNS = {
						direct : function() {
							display("DirectEvalResultArea", direct);
						},
						indirect : function() {
							display("IndirectEvalResultArea", indirect);
						}
					};

				}(window, document));
			</script>
		</section>
		<section>
			<h2>with</h2>
			<p>with文の問題のために入力された名前は決して使われない。</p>
			<div id="WithResultArea">結果確認</div>
			<div>
				<label>名前:<input id="WithSampleName" type="text" value="" /></label>
				<button onclick="withNS.displayName();">名前確認</button>
				<button onclick="withNS.changeObject();">メソッド変更</button>
			</div>
			<script>
				(function(win, doc){
					
					var area = my.ref("WithResultArea"),
						nameInput = my.ref("WithSampleName");
					
					function getName(){
						return nameInput.value;
					}
					
					function Sample(name, id){
						this.name = name;
						this.id = id;
					}
					
					Sample.prototype = {
						setName : function(name){
							this.name = name;
						},
						getName : function(){
							return this.name;
						}
					};
					
					function setupObject(name){
						var sample = new Sample("NONAME", 1);
						
						with(sample){
							/**
							 * 引数のname変数ではなくオブジェクトに設定済みの
							 * nameプロパティが使われ続ける。 
							 */
							setName(name);
							/**
							 * 意図せずSampleのメソッドが呼び出されてしまう。 
							 * そのメソッドは変更されているかもしれない。
							 */
							my.log(getName());
						}
						
						return sample;
					}
					
					function changeSampleMethod(){
						/**
						 * setupObjectで呼び出しているつもりの無い
						 * メソッドを変更してしまう。
						 */
						Sample.prototype.getName = function(){
							return this.name + " CHANGED!!";
						};
					}
					
					(function init(){
						
						my.export("withNS", {
							displayName : function(){
								var sample = setupObject(getName());
								my.println(area, sample.getName(), true);
							},
							changeObject : function(){
								changeSampleMethod();
								my.log("Sample.prototype.getName is changed!");
							}
						});
						
					}());
					
				}(window, document));
			</script>
		</section>
	</main>

	<footer role="contentinfo">
		<small>Copyright &copy; 2014 moguonyanko All rights reserved.</small>
	</footer>
</body>
</html>
